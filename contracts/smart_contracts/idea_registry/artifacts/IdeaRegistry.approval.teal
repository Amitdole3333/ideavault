#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 44
    bytecblock "total_ideas" 0x151f7c75
    // smart_contracts/idea_registry/contract.py:42
    // class IdeaRegistry(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@10
    pushbytess 0xa2574c93 0x83ba8207 0x774e0e85 0x7bc42436 // method "register_idea(byte[32],string,string)uint64", method "verify_idea(byte[32])bool", method "get_idea(byte[32])(address,uint64,string)", method "get_total_ideas()uint64"
    txna ApplicationArgs 0
    match register_idea verify_idea get_idea get_total_ideas
    err

main_create_NoOp@10:
    // smart_contracts/idea_registry/contract.py:42
    // class IdeaRegistry(ARC4Contract):
    pushbytes 0x752c3ac0 // method "create_application()void"
    txna ApplicationArgs 0
    match create_application
    err


// contract.IdeaRegistry.create_application[routing]() -> void:
create_application:
    // smart_contracts/idea_registry/contract.py:64
    // self.total_ideas.value = UInt64(0)
    bytec_0 // "total_ideas"
    intc_0 // 0
    app_global_put
    // smart_contracts/idea_registry/contract.py:65
    // log(b"IdeaVault:initialized")
    pushbytes 0x496465615661756c743a696e697469616c697a6564
    log
    // smart_contracts/idea_registry/contract.py:61
    // @arc4.abimethod(create="require")
    intc_1 // 1
    return


// contract.IdeaRegistry.register_idea[routing]() -> void:
register_idea:
    // smart_contracts/idea_registry/contract.py:67
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    dup
    uncover 2
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // smart_contracts/idea_registry/contract.py:91-92
    // # Reject duplicate hash submissions
    // length, exists = op.Box.length(box_key)
    dig 2
    box_len
    bury 1
    // smart_contracts/idea_registry/contract.py:93
    // assert not exists, "ERR:DUPLICATE_HASH"
    !
    assert // ERR:DUPLICATE_HASH
    // smart_contracts/idea_registry/contract.py:98-99
    // # Encode value: sender_address(32) + timestamp(8) + cid_len(4) + cid_bytes
    // founder_bytes = Txn.sender.bytes
    txn Sender
    // smart_contracts/idea_registry/contract.py:95-96
    // # Get current timestamp from Algorand ledger
    // timestamp = Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/idea_registry/contract.py:100
    // ts_bytes = op.itob(timestamp)
    itob
    // smart_contracts/idea_registry/contract.py:102
    // cid_len = op.itob(cid_bytes.length)
    uncover 2
    itob
    // smart_contracts/idea_registry/contract.py:104
    // value = founder_bytes + ts_bytes + cid_len + cid_bytes
    dig 2
    dig 2
    concat
    swap
    concat
    uncover 3
    concat
    // smart_contracts/idea_registry/contract.py:105
    // op.Box.put(box_key, value)
    uncover 3
    swap
    box_put
    // smart_contracts/idea_registry/contract.py:107-108
    // # Improvement 3: Increment global counter
    // self.total_ideas.value += UInt64(1)
    intc_0 // 0
    bytec_0 // "total_ideas"
    app_global_get_ex
    assert // check self.total_ideas exists
    intc_1 // 1
    +
    bytec_0 // "total_ideas"
    swap
    app_global_put
    // smart_contracts/idea_registry/contract.py:110-112
    // # Improvement 1: Emit event log for blockchain transparency
    // # Format: "IDEA_REGISTERED:<txn_sender>:<timestamp>"
    // log(b"IDEA_REGISTERED:" + founder_bytes + b":" + ts_bytes)
    pushbytes 0x494445415f524547495354455245443a
    uncover 2
    concat
    pushbytes 0x3a
    concat
    dig 1
    concat
    log
    // smart_contracts/idea_registry/contract.py:67
    // @arc4.abimethod()
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contract.IdeaRegistry.verify_idea[routing]() -> void:
verify_idea:
    // smart_contracts/idea_registry/contract.py:116
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/idea_registry/contract.py:128
    // length, exists = op.Box.length(idea_hash.bytes)
    box_len
    bury 1
    // smart_contracts/idea_registry/contract.py:129
    // return arc4.Bool(exists)
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/idea_registry/contract.py:116
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contract.IdeaRegistry.get_idea[routing]() -> void:
get_idea:
    // smart_contracts/idea_registry/contract.py:131
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/idea_registry/contract.py:143
    // value, exists = op.Box.get(idea_hash.bytes)
    box_get
    // smart_contracts/idea_registry/contract.py:144
    // assert exists, "ERR:IDEA_NOT_FOUND"
    assert // ERR:IDEA_NOT_FOUND
    // smart_contracts/idea_registry/contract.py:146-147
    // # Decode stored value
    // founder_addr_bytes = value[0:32]
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    intc_2 // 32
    dig 2
    >=
    intc_2 // 32
    dig 3
    uncover 2
    select
    dig 3
    uncover 2
    dig 2
    substring3
    // smart_contracts/idea_registry/contract.py:148
    // timestamp_bytes = value[32:40]
    pushint 40
    dig 3
    >=
    pushint 40
    dig 4
    uncover 2
    select
    dig 4
    uncover 3
    dig 2
    substring3
    // smart_contracts/idea_registry/contract.py:149
    // cid_len_bytes = value[40:44]
    intc_3 // 44
    dig 4
    >=
    intc_3 // 44
    dig 5
    uncover 2
    select
    dig 5
    uncover 3
    dig 2
    substring3
    // smart_contracts/idea_registry/contract.py:151
    // cid_len = op.btoi(cid_len_bytes)
    btoi
    // smart_contracts/idea_registry/contract.py:152
    // cid_bytes = value[44 : 44 + cid_len]
    intc_3 // 44
    +
    dup
    dig 5
    >=
    swap
    uncover 5
    uncover 2
    select
    dup
    dig 2
    <
    dig 2
    swap
    select
    uncover 4
    cover 2
    substring3
    // smart_contracts/idea_registry/contract.py:155
    // arc4.Address(founder_addr_bytes),
    dig 2
    len
    intc_2 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/idea_registry/contract.py:156
    // arc4.UInt64(op.btoi(timestamp_bytes)),
    swap
    btoi
    itob
    // smart_contracts/idea_registry/contract.py:154-158
    // return arc4.Tuple((
    //     arc4.Address(founder_addr_bytes),
    //     arc4.UInt64(op.btoi(timestamp_bytes)),
    //     arc4.String.from_bytes(cid_bytes),
    // ))
    uncover 2
    swap
    concat
    pushbytes 0x002a
    concat
    swap
    concat
    // smart_contracts/idea_registry/contract.py:131
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contract.IdeaRegistry.get_total_ideas[routing]() -> void:
get_total_ideas:
    // smart_contracts/idea_registry/contract.py:166
    // return arc4.UInt64(self.total_ideas.value)
    intc_0 // 0
    bytec_0 // "total_ideas"
    app_global_get_ex
    assert // check self.total_ideas exists
    itob
    // smart_contracts/idea_registry/contract.py:160
    // @arc4.abimethod(readonly=True)
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return
